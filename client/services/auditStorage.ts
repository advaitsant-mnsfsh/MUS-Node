import { AnalysisReport, Screenshot } from '../types';

export interface SharedAuditData {
    id: string;
    url: string;
    report: AnalysisReport;
    screenshots: Screenshot[];
    screenshotMimeType: string;
    whiteLabelLogo?: string | null;
    createdAt: string;
}

// Backend URL logic
const backendUrl = import.meta.env.VITE_BACKEND_URL || import.meta.env.VITE_API_URL || (import.meta.env.PROD ? 'https://mus-node-production.up.railway.app' : 'http://localhost:8080');

/**
 * Save audit data (Unified Flow)
 * Since every audit is now a 'job' in the backend, this is mostly a pass-through
 * or used to ensure the audit exists.
 */
export async function saveSharedAudit(data: {
    url: string;
    report: AnalysisReport;
    screenshots: Screenshot[];
    screenshotMimeType: string;
    whiteLabelLogo?: string | null;
}): Promise<string> {
    console.warn('[auditStorage] saveSharedAudit called without ID. Falling back to local state (Audit IDs should ideally be pre-generated by the backend).');

    // In the new architecture, we should always have a jobId from the start.
    // If we don't, we return a temporary ID or handle it.
    return 'unsaved-' + Date.now();
}

/**
 * Retrieve shared audit data by ID from the DB
 * Returns null if not found
 */
export async function getSharedAudit(auditId: string): Promise<SharedAuditData | null> {
    // Forward to getAuditJob logic which queries API (unified)
    const job = await getAuditJob(auditId);
    if (!job || !job.report_data) return null;

    const report = job.report_data;
    const screenshots = report.screenshots || [];

    // Fallback if report.screenshots is empty but we have report.screenshotBase64
    if (screenshots.length === 0 && report.screenshotBase64) {
        screenshots.push({
            url: '',
            data: report.screenshotBase64,
            isMobile: false
        });
    }

    return {
        id: job.id,
        url: report.url || 'Unknown URL',
        report: report,
        screenshots: screenshots,
        screenshotMimeType: report.screenshotMimeType || 'image/jpeg',
        whiteLabelLogo: null,
        createdAt: new Date().toISOString()
    };
}


export interface AuditJobData {
    id: string;
    status: 'pending' | 'processing' | 'completed' | 'failed';
    report_data?: any;
    error_message?: string;
    redirectUrl?: string; // Optional if you need to know where it would have gone
    inputs?: any[]; // AuditInput[] array
}

// Basic In-Memory Cache to prevent redundant fetches
const jobCache = new Map<string, Promise<AuditJobData | null>>();

export async function getAuditJob(jobId: string): Promise<AuditJobData | null> {
    // Check cache first
    const cached = jobCache.get(jobId);
    if (cached) return cached;

    const jobPromise = (async () => {
        try {
            // Prioritize API over Storage (since we stopped using Storage)
            // Try API endpoint
            const response = await fetch(`${backendUrl}/api/public/jobs/${jobId}`);
            if (response.ok) {
                const apiData = await response.json();
                return {
                    id: apiData.id,
                    status: apiData.status,
                    report_data: apiData.report_data,
                    error_message: apiData.error_message, // API might return errorMessage or error_message
                    inputs: apiData.inputs // Capture inputs from API
                };
            }

            console.warn('API fetch failed for job:', jobId);
            return null;

        } catch (error) {
            console.error('Error fetching job:', error);
            return null;
        }
    })();

    // Store in cache
    jobCache.set(jobId, jobPromise);

    // Optional: Clear cache after 30 seconds to allow for fresh data if job status changes
    setTimeout(() => { jobCache.delete(jobId); }, 30000);

    return jobPromise;
}



/**
 * Transfer audit ownership from guest/null user to logged-in user
 * Uses Backend API to bypass RLS restrictions
 */
export async function transferAuditOwnership(auditId: string, userId: string): Promise<{ success: boolean; error?: string }> {
    console.log(`[auditStorage] Request received: Transfer Audit ${auditId} -> User ${userId}`);

    try {
        const { authClient } = await import('../lib/auth-client');

        // Use authClient's own fetcher to ensure all CSRF and session headers are handled correctly for cross-site
        try {
            // Get current session to use its token as a fallback header
            const { data: session } = await authClient.getSession();
            const sessionToken = (session as any)?.session?.token;

            const response: any = await authClient.$fetch(`${backendUrl}/api/v1/audit/claim`, {
                method: 'POST',
                body: { auditId },
                credentials: 'include', // CRITICAL for cross-site cookies
                headers: sessionToken ? {
                    'Authorization': `Bearer ${sessionToken}`
                } : {}
            });

            if (!response?.success) {
                console.error('[auditStorage] ‚ùå API Error transferring ownership:', response?.error);
                return { success: false, error: response?.error || 'API Failed' };
            }
        } catch (fetchErr: any) {
            // Handle cases where the response might not be JSON (e.g. 404 HTML page)
            console.error('[auditStorage] üí• Fetch Error in transferAuditOwnership:', fetchErr);
            const errorMessage = (fetchErr.response?._data?.error) || fetchErr.message || 'Network error';
            return { success: false, error: errorMessage };
        }

        console.log(`[auditStorage] ‚úÖ Successfully transferred audit ${auditId} to user ${userId} (via Admin API)`);
        return { success: true };

    } catch (error) {
        console.error('[auditStorage] üí• Unexpected Error in transferAuditOwnership:', error);
        return { success: false, error: String(error) };
    }
}
